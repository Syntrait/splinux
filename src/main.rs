mod gui;
mod native_backend;
mod types;

use clap::{Arg, ArgAction, Command};
use gui::start;
use native_backend::backend as nativebackend;
use std::{
    env::args,
    path::{Path, PathBuf},
};
use types::Backend;

fn main() {
    let args1: Vec<String> = args().collect();
    if args1.len() == 1 {
        start();
        return;
    }

    let matches = Command::new("splinux")
        .about("split-screen solution for linux")
        .version(option_env!("CARGO_PKG_VERSION").unwrap_or("unknown"))
        .subcommand(Command::new("gui").long_flag("gui").about("show the gui"))
        .subcommand(
            Command::new("run")
                .long_flag("run")
                .about("convert device input to display input, according to the preset file")
                .arg(
                    Arg::new("presetfile")
                        .short('f')
                        .long("file")
                        .help("the path to preset file, generated by the gui")
                        .action(ArgAction::Set)
                        .num_args(1)
                        .required(true),
                ),
        )
        .get_matches();

    match matches.subcommand() {
        Some(("gui", _)) => {
            start();
        }
        Some(("run", x)) => {
            let preset_path_string: &String = x.get_one("presetfile").unwrap();
            let preset_path: PathBuf = preset_path_string.into();

            // TODO: headless support
            // TODO: figure out and make this work
            //nativebackend(input.to_owned(), "".to_owned());
        }
        _ => unreachable!(),
    }
}
